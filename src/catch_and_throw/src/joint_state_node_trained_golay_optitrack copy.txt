#include <rclcpp/rclcpp.hpp>
#include <sensor_msgs/msg/joint_state.hpp>
#include <geometry_msgs/msg/pose.hpp>
#include <geometry_msgs/msg/twist.hpp>
#include <geometry_msgs/msg/pose_stamped.hpp>  // For OptiTrack
#include <lbr_fri_idl/msg/lbr_joint_position_command.hpp>
#include <torch/torch.h>
#include <torch/script.h>

#include <Eigen/Geometry>

#include <fstream>
#include <vector>
#include <string>
#include <thread>
#include <chrono>
#include <filesystem>
#include <algorithm>
#include <sstream>
#include <mutex>
#include <cmath>
#include <numeric>
#include <deque>

using std::placeholders::_1;
using namespace std::chrono_literals;
namespace fs = std::filesystem;

// Forward declarations
class RealTimeSavitzkyGolay;
class DeploymentPolicy;
class JointStateNode;

// Low-pass filter for velocity calculation
class LowPassFilter {
public:
    LowPassFilter(double cutoff_hz, double sample_rate_hz, torch::Tensor initial_state = torch::Tensor()) {
        double dt = 1.0 / sample_rate_hz;
        alpha_ = std::exp(-2.0 * M_PI * cutoff_hz * dt);
        
        if (initial_state.numel() == 0) {
            prev_ = torch::zeros(1);
        } else {
            prev_ = initial_state.clone().to(torch::kFloat64);
        }
    }
    
    torch::Tensor operator()(const torch::Tensor& x) {
        auto x_float = x.to(torch::kFloat64);
        auto y = alpha_ * prev_ + (1.0 - alpha_) * x_float;
        prev_ = y.clone();
        return y;
    }
    
private:
    double alpha_;
    torch::Tensor prev_;
};

// RealTimeSavitzkyGolay class for signal smoothing
class RealTimeSavitzkyGolay {
public:
    RealTimeSavitzkyGolay(int window_length = 9, 
                          int polyorder = 3, 
                          int deriv = 0, 
                          double delta = 1.0,
                          torch::Tensor initial_values = torch::Tensor()) {
        
        if (window_length % 2 == 0) {
            window_length += 1;
            std::cout << "Warning: window_length adjusted to odd value: " << window_length << std::endl;
        }
        
        if (polyorder >= window_length) {
            polyorder = window_length - 1;
            std::cout << "Warning: polyorder too large, reduced to " << polyorder << std::endl;
        }
        
        window_length_ = window_length;
        polyorder_ = polyorder;
        
        coeffs_ = compute_savgol_coeffs_smooth(window_length_, polyorder_);
        
        if (initial_values.numel() > 0) {
            bool is_batched = initial_values.dim() > 1;
            
            if (is_batched) {
                if (initial_values.size(0) >= window_length_) {
                    buffer_ = initial_values.slice(0, initial_values.size(0) - window_length_, initial_values.size(0)).clone();
                } else {
                    auto first_value = initial_values[0].unsqueeze(0);
                    auto padding = first_value.repeat({window_length_ - initial_values.size(0), 1});
                    buffer_ = torch::cat({padding, initial_values}, 0);
                }
            } else {
                if (initial_values.size(0) >= window_length_) {
                    buffer_ = initial_values.slice(0, initial_values.size(0) - window_length_, initial_values.size(0)).clone();
                } else {
                    float first_val = initial_values.size(0) > 0 ? initial_values[0].item<float>() : 0.0f;
                    auto padding = torch::full({window_length_ - initial_values.size(0)}, first_val);
                    buffer_ = torch::cat({padding, initial_values}, 0);
                }
            }
        } else {
            buffer_ = torch::zeros({window_length_});
            buffer_initialized_ = false;
        }
        
        current_idx_ = 0;
    }
    
    torch::Tensor operator()(const torch::Tensor& x) {
        if (!buffer_initialized_) {
            if (x.dim() > 0 && x.size(0) > 1) {
                buffer_ = torch::zeros({window_length_, x.size(0)}).to(x.device(), x.dtype());
            }
            buffer_initialized_ = true;
        }
        
        if (x.dim() == 0) {
            buffer_[current_idx_] = x.item<float>();
        } else {
            buffer_[current_idx_] = x;
        }
        
        current_idx_ = (current_idx_ + 1) % window_length_;
        
        torch::Tensor ordered_buffer;
        if (current_idx_ == 0) {
            ordered_buffer = buffer_;
        } else {
            ordered_buffer = torch::cat({
                buffer_.slice(0, current_idx_, window_length_),
                buffer_.slice(0, 0, current_idx_)
            }, 0);
        }
        
        torch::Tensor filtered_value;
        
        if (ordered_buffer.dim() == 1) {
            filtered_value = (ordered_buffer * coeffs_).sum();
        } else {
            filtered_value = torch::zeros_like(x);
            for (int i = 0; i < ordered_buffer.size(1); i++) {
                filtered_value[i] = (ordered_buffer.select(1, i) * coeffs_).sum();
            }
        }
        
        return filtered_value;
    }
    
private:
    int window_length_;
    int polyorder_;
    torch::Tensor coeffs_;
    torch::Tensor buffer_;
    int current_idx_;
    bool buffer_initialized_ = true;
    
    torch::Tensor compute_savgol_coeffs_smooth(int window_length, int polyorder) {
        int half_window = window_length / 2;
        
        auto options = torch::TensorOptions().dtype(torch::kFloat32);
        torch::Tensor x = torch::arange(-half_window, half_window + 1, options);
        torch::Tensor vander = torch::zeros({window_length, polyorder + 1});
        
        for (int i = 0; i <= polyorder; i++) {
            vander.select(1, i) = torch::pow(x, i);
        }
        
        auto qr = torch::linalg_qr(vander);
        auto q = std::get<0>(qr);
        auto r = std::get<1>(qr);
        
        torch::Tensor target = torch::zeros({polyorder + 1});
        target[0] = 1.0;
        
        torch::Tensor qtb = torch::matmul(q.transpose(0, 1), target);
        
        torch::Tensor coeffs = torch::zeros({polyorder + 1});
        for (int k = polyorder; k >= 0; k--) {
            coeffs[k] = qtb[k];
            for (int j = k + 1; j <= polyorder; j++) {
                coeffs[k] -= coeffs[j] * r.index({k, j});
            }
            coeffs[k] /= r.index({k, k});
        }
        
        torch::Tensor sg_coeffs = torch::matmul(vander, coeffs);
        
        return sg_coeffs;
    }
};

// DeploymentPolicy class for loading and running the policy
class DeploymentPolicy {
public:
    DeploymentPolicy(const std::string& checkpoint_path) {
        try {
            model = torch::jit::load(checkpoint_path);
            model.eval();
        } catch (const c10::Error& e) {
            throw std::runtime_error("Error loading model: " + std::string(e.what()));
        }
    }

    torch::Tensor get_action(const torch::Tensor& raw_obs) {
        auto obs_tensor = raw_obs.unsqueeze(0).to(torch::kCPU).to(torch::kFloat32);
        
        torch::NoGradGuard no_grad;
        auto action = model.forward({obs_tensor}).toTensor();
        
        return action.squeeze(0);
    }

private:
    torch::jit::Module model;
};

class JointStateNode : public rclcpp::Node {
public:
    JointStateNode()
    : Node("joint_state_node"), t_(0), recording_(false), 
      catching_ball_index_(0), stabilizing_ball_index_(1), stabilized_ball_index_(2),
      moving_to_target_pos_index_(3), stabilized_at_target_index_(4), 
      throwing_ball_index_(5), stop_manipulator_index_(6) {
        
        using QoS = rclcpp::QoS;
        auto qos = QoS(rclcpp::KeepLast(10)).reliable();

        // Declare parameters
        this->declare_parameter<std::string>("model_path", 
            "/home/user/kuka_rl_ros2/src/catch_and_throw/input_files/idealpd/policy.pt");
        this->declare_parameter<int>("sg_window_length", 9);
        this->declare_parameter<int>("sg_polyorder", 3);
        this->declare_parameter<double>("ball_velocity_filter_cutoff", 10.0);
        this->declare_parameter<double>("tennisball_radius", 0.032);

        // Hyperparameters matching Python script
        dt_ = 1.0 / 200.0;
        tennis_ball_pos_scale_ = 0.25;
        lin_vel_scale_ = 0.15;
        to_final_target_scale_ = 0.5;
        dof_vel_scale_ = 0.31;
        action_scale_ = 0.09;
        to_throwing_pos_scale_ = 0.5;
        to_throwing_vel_scale_ = 0.4;
        moving_average_ = 0.8;

        // Tennis ball configuration
        tennisball_radius_ = this->get_parameter("tennisball_radius").as_double();

        // Joint limits
        robot_dof_lower_limits_ = torch::tensor({-2.9671, -2.0944, -2.9671, -2.0944, -2.9671, -2.0944, -3.0543});
        robot_dof_upper_limits_ = torch::tensor({2.9671, 2.0944, 2.9671, 2.0944, 2.9671, 2.0944, 3.0543});

        robot_dof_lower_limits_np_ = robot_dof_lower_limits_.clone();
        robot_dof_upper_limits_np_ = robot_dof_upper_limits_.clone();

        // Final target and throwing parameters
        final_target_pos_ = torch::tensor({-0.65, -0.4, 0.55});
        throwing_pos_ = torch::tensor({0.2, -0.35, 0.9});
        throwing_vel_ = torch::tensor({2.5, 0.0, 0.5});

        // Initialize policy
        std::string model_path = this->get_parameter("model_path").as_string();
        policy_ = std::make_unique<DeploymentPolicy>(model_path);

        // Initialize action history and other buffers
        action_history_ = torch::zeros({2, 7});
        action_logits_ = torch::zeros(7);
        pure_action_ = torch::zeros(7);
        robot_dof_targets_ = torch::zeros(7);

        // Initialize task state variables
        current_task_ = torch::zeros(7);
        current_task_[catching_ball_index_] = 1.0;  // Start with catching ball task
        catched_ball_ = false;
        stabilized_ball_ = false;
        stabilized_ball_counter_ = 0;
        stabilized_ball_counter_at_target_ = 0;
        throwing_termination_ = false;
        revert_penalty_ = 0.0;

        // Initialize ball position history for velocity calculation
        double velocity_filter_cutoff = this->get_parameter("ball_velocity_filter_cutoff").as_double();
        ball_velocity_filter_ = std::make_unique<LowPassFilter>(velocity_filter_cutoff, 1.0/dt_);
        
        // Initialize Savitzky-Golay filter for action smoothing
        int sg_window_length = this->get_parameter("sg_window_length").as_int();
        int sg_polyorder = this->get_parameter("sg_polyorder").as_int();
        action_filter_ = std::make_unique<RealTimeSavitzkyGolay>(
            sg_window_length, sg_polyorder, 0, dt_, torch::zeros(7));

        // Subscribers
        joint_states_sub_ = this->create_subscription<sensor_msgs::msg::JointState>(
            "/lbr/joint_states", qos, std::bind(&JointStateNode::joint_states_callback, this, _1));

        ee_pose_sub_ = this->create_subscription<geometry_msgs::msg::Pose>(
            "/lbr/state/pose", qos, std::bind(&JointStateNode::ee_pose_callback, this, _1));

        ee_vel_sub_ = this->create_subscription<geometry_msgs::msg::Twist>(
            "/lbr/state/twist", qos, std::bind(&JointStateNode::ee_vel_callback, this, _1));

        // OptiTrack ball position subscription
        ball_pose_sub_ = this->create_subscription<geometry_msgs::msg::PoseStamped>(
            "/optitrack/ball", qos, std::bind(&JointStateNode::ball_pose_callback, this, _1));

        // Publisher
        joint_ref_pub_ = this->create_publisher<lbr_fri_idl::msg::LBRJointPositionCommand>(
            "/lbr/command/joint_position", 10);

        // Timer for action computation
        timer_ = this->create_wall_timer(
            std::chrono::duration<double>(dt_), 
            std::bind(&JointStateNode::compute_action_and_publish, this)
        );

        RCLCPP_INFO(this->get_logger(), "JointStateNode initialized with OptiTrack ball tracking");
        RCLCPP_INFO(this->get_logger(), "Savitzky-Golay filter parameters: window=%d, polyorder=%d", 
                   sg_window_length, sg_polyorder);
        RCLCPP_INFO(this->get_logger(), "Ball velocity filter cutoff: %.2f Hz", velocity_filter_cutoff);
    }

    // Helper function to convert PyTorch tensor to std::vector<double>
    std::vector<double> tensor_to_vector(const torch::Tensor& tensor) {
        std::vector<double> result;
        result.reserve(tensor.numel());
        
        auto cpu_tensor = tensor.to(torch::kCPU).contiguous();
        
        if (cpu_tensor.dtype() == torch::kFloat32) {
            float* data_ptr = cpu_tensor.data_ptr<float>();
            for (int i = 0; i < cpu_tensor.numel(); i++) {
                result.push_back(static_cast<double>(data_ptr[i]));
            }
        } else if (cpu_tensor.dtype() == torch::kFloat64) {
            double* data_ptr = cpu_tensor.data_ptr<double>();
            for (int i = 0; i < cpu_tensor.numel(); i++) {
                result.push_back(data_ptr[i]);
            }
        } else {
            for (int i = 0; i < cpu_tensor.numel(); i++) {
                result.push_back(cpu_tensor.flatten()[i].item<double>());
            }
        }
        
        return result;
    }

    void update_task_state() {
        // Get current ball and end effector positions
        torch::Tensor distance = torch::norm(tennisball_pos_ - ee_pose_, 2);
        torch::Tensor rel_position_termination = torch::norm(tennisball_pos_ - ee_pose_, 2);
        
        // Get current task indices (find which task is active)
        int current_task_index = -1;
        for (int i = 0; i < 7; i++) {
            if (current_task_[i].item<float>() == 1.0) {
                current_task_index = i;
                break;
            }
        }

        // Define masks for current tasks
        bool in_catching_ball = (current_task_index == catching_ball_index_);
        bool in_stabilizing_ball = (current_task_index == stabilizing_ball_index_);
        bool in_stabilized_ball = (current_task_index == stabilized_ball_index_);
        bool in_moving_to_target = (current_task_index == moving_to_target_pos_index_);
        bool in_stabilized_at_target = (current_task_index == stabilized_at_target_index_);
        bool in_throwing_ball = (current_task_index == throwing_ball_index_);
        bool in_stop_manipulator = (current_task_index == stop_manipulator_index_);

        // Check if the ball is caught
        catched_ball_ = (distance.item<float>() < 0.12) && 
                        (rel_position_termination.item<float>() < tennisball_radius_ * 1.5);

        // Transition logic
        bool can_transition_to_stabilizing_ball = catched_ball_ && in_catching_ball;
        bool can_revert_to_catching_ball = !catched_ball_ && in_stabilizing_ball;

        // Update tasks for 'Catching_Ball' ↔ 'Stabilizing_Ball'
        if (can_transition_to_stabilizing_ball) {
            current_task_ = torch::zeros(7);
            current_task_[stabilizing_ball_index_] = 1.0;
        }
        if (can_revert_to_catching_ball) {
            current_task_ = torch::zeros(7);
            current_task_[catching_ball_index_] = 1.0;
            revert_penalty_ = -0.4;
        }

        // Conditions for 'Stabilized_Ball'
        bool distance_condition = (distance.item<float>() < 0.12) && 
                                  (rel_position_termination.item<float>() < tennisball_radius_ * 1.2);
        bool velocity_condition = torch::norm(tennisball_lin_vel_, 2).item<float>() < 0.1;
        bool rel_velocity_condition = torch::norm(tennisball_lin_vel_ - ee_vel_, 2).item<float>() < 0.1;

        stabilized_ball_ = distance_condition && velocity_condition && rel_velocity_condition && 
                           (in_stabilizing_ball || in_stabilized_ball);
        
        bool can_revert_to_stabilizing_ball = (!distance_condition || !velocity_condition || 
                                               !rel_velocity_condition) && in_stabilized_ball;

        // Update tasks for 'Stabilizing_Ball' ↔ 'Stabilized_Ball'
        if (stabilized_ball_) {
            current_task_ = torch::zeros(7);
            current_task_[stabilized_ball_index_] = 1.0;
            stabilized_ball_counter_++;
        }
        if (can_revert_to_stabilizing_ball) {
            current_task_ = torch::zeros(7);
            current_task_[stabilizing_ball_index_] = 1.0;
            stabilized_ball_counter_--;
            revert_penalty_ = -0.4;
        }

        bool rel_velocity_condition_to_target = torch::norm(tennisball_lin_vel_ - ee_vel_, 2).item<float>() < 0.1;

        bool moving_to_target_pos = (stabilized_ball_counter_ > 150) && distance_condition && 
                                    rel_velocity_condition_to_target;
        bool can_revert_to_stabilized_ball = !moving_to_target_pos && in_moving_to_target;

        if (moving_to_target_pos) {
            current_task_ = torch::zeros(7);
            current_task_[moving_to_target_pos_index_] = 1.0;
        }
        if (can_revert_to_stabilized_ball) {
            current_task_ = torch::zeros(7);
            current_task_[stabilized_ball_index_] = 1.0;
            revert_penalty_ = -0.4;
        }

        // Transition to 'Stabilized_at_Target' from 'Moving_to_target_pos'
        torch::Tensor dist_to_target_pos = torch::norm(final_target_pos_ - tennisball_pos_, 2);
        bool final_rel_dis_cond = (distance.item<float>() < 0.12) && 
                                  (rel_position_termination.item<float>() < tennisball_radius_ * 1.2);
        bool final_vel_cond = torch::norm(tennisball_lin_vel_, 2).item<float>() < 0.1;
        bool final_rel_velocity_condition = torch::norm(tennisball_lin_vel_ - ee_vel_, 2).item<float>() < 0.1;
        bool final_target_dist_reward = dist_to_target_pos.item<float>() < 0.1;

        bool stabilized_at_target = final_rel_dis_cond && final_vel_cond && 
                                    final_rel_velocity_condition && final_target_dist_reward && 
                                    (in_moving_to_target || in_stabilized_at_target);

        bool can_revert_to_moving_to_target = !final_rel_dis_cond && in_stabilized_at_target;

        if (stabilized_at_target) {
            current_task_ = torch::zeros(7);
            current_task_[stabilized_at_target_index_] = 1.0;
            stabilized_ball_counter_at_target_++;
        }
        if (can_revert_to_moving_to_target) {
            current_task_ = torch::zeros(7);
            current_task_[moving_to_target_pos_index_] = 1.0;
            stabilized_ball_counter_at_target_--;
            revert_penalty_ = -0.4;
        }

        bool throwing_ball = (stabilized_ball_counter_at_target_ > 50);

        if (throwing_ball) {
            current_task_ = torch::zeros(7);
            current_task_[throwing_ball_index_] = 1.0;
            throwing_termination_ = true;
        }

        bool stop_manipulator = (in_throwing_ball && (tennisball_pos_[0].item<float>() > 0.2)) || 
                                in_stop_manipulator;

        if (stop_manipulator) {
            current_task_ = torch::zeros(7);
            current_task_[stop_manipulator_index_] = 1.0;
        }
    }

    void compute_action_and_publish() {
        std::lock_guard<std::mutex> lock(mutex_);

        // Check if we have all necessary data
        if (joint_positions_obs_.numel() == 0 || joint_velocities_obs_.numel() == 0 ||
            ee_pose_.numel() == 0 || ee_orientation_.numel() == 0 || 
            ee_vel_.numel() == 0 || ee_angular_vel_.numel() == 0 ||
            tennisball_pos_.numel() == 0) {
            return;
        }

        // Update task state based on current conditions
        update_task_state();

        // Scale joint observations
        auto dof_pos_scaled_obs = 2.0 * (joint_positions_obs_ - robot_dof_lower_limits_np_) / 
            (robot_dof_upper_limits_np_ - robot_dof_lower_limits_np_) - 1.0;
        auto dof_vel_scaled_obs = joint_velocities_obs_ * dof_vel_scale_;

        // Scale observations
        torch::Tensor tennisball_pos_obs = tennisball_pos_ * tennis_ball_pos_scale_;
        torch::Tensor tennisball_lin_vel_obs = tennisball_lin_vel_ * lin_vel_scale_;
        torch::Tensor ee_lin_vel_scaled = ee_vel_ * lin_vel_scale_;

        // Compute conditions for targets
        bool condition_final_target = (current_task_[moving_to_target_pos_index_].item<float>() == 1.0) || 
                                       (current_task_[stabilized_at_target_index_].item<float>() == 1.0);
        bool condition_throwing = (current_task_[throwing_ball_index_].item<float>() == 1.0);

        // Prepare actions
        torch::Tensor action = action_logits_.numel() == 0 ? 
            torch::ones(7) : action_logits_;
        torch::Tensor pure_action = pure_action_.numel() == 0 ? 
            torch::zeros(7) : pure_action_;

        // Compute target vectors
        torch::Tensor to_final_target = condition_final_target ? 
            (final_target_pos_ - tennisball_pos_obs) : 
            torch::zeros({3});

        torch::Tensor to_throwing_vel = condition_throwing ? 
            (throwing_vel_ - tennisball_lin_vel_obs) : 
            torch::zeros({3});

        torch::Tensor to_throwing_pos = condition_throwing ? 
            (throwing_pos_ - tennisball_pos_obs) : 
            torch::zeros({3});

        // Compute scaled vectors
        to_final_target *= to_final_target_scale_;
        to_throwing_pos *= to_throwing_pos_scale_;
        to_throwing_vel *= to_throwing_vel_scale_;

        // Update action history
        action_history_ = torch::roll(action_history_, -1, 0);
        action_history_[-1] = pure_action;

        // Compute offset point
        torch::Tensor ee_pos_for_obs;
        if (ee_pose_.numel() > 0 && ee_orientation_.numel() > 0) {
            ee_pos_for_obs = compute_offset_point(ee_pose_, ee_orientation_);
        } else {
            ee_pos_for_obs = torch::tensor({0.33434677, -0.33252597, 0.9089085});
        }

        // Prepare observation tensor
        torch::Tensor observations = torch::cat({
            action.flatten(),               // 7
            action_history_.flatten(),      // 14 (2x7)
            dof_pos_scaled_obs.flatten(),   // 7
            dof_vel_scaled_obs.flatten(),   // 7
            tennisball_pos_obs.flatten(),   // 3
            ee_pos_for_obs.flatten(),       // 3
            tennisball_lin_vel_obs.flatten(), // 3
            ee_lin_vel_scaled.flatten(),    // 3
            ee_orientation_.flatten(),      // 4
            to_final_target.flatten(),      // 3
            to_throwing_pos.flatten(),      // 3
            to_throwing_vel.flatten(),      // 3
            current_task_.flatten()         // 7 (obs_task)
        });

        // Sanity check observation size
        assert(observations.size(0) == 67);

        // Get action from policy
        torch::Tensor raw_action = policy_->get_action(observations);
        
        // Apply low-pass filter to the action
        action_logits_ = (*action_filter_)(raw_action);
        
        // Store the raw (unfiltered) action for debugging
        raw_action_history_.push_back(tensor_to_vector(raw_action));
        filtered_action_history_.push_back(tensor_to_vector(action_logits_));

        // Compute new targets
        torch::Tensor targets = joint_positions_obs_ + (action_logits_ * 0.1);
        robot_dof_targets_ = torch::clamp(
            targets,
            0.975 * robot_dof_lower_limits_,
            0.975 * robot_dof_upper_limits_
        );

        // Save outputs for logging/debugging
        joint_targets_.push_back(tensor_to_vector(targets));
        joint_poses_.push_back(tensor_to_vector(joint_positions_obs_));
        joint_velocities_.push_back(tensor_to_vector(joint_velocities_obs_));
        ee_poses_.push_back(tensor_to_vector(ee_pose_));
        ee_orientations_.push_back(tensor_to_vector(ee_orientation_));
        ee_velocities_.push_back(tensor_to_vector(ee_vel_));
        ball_positions_.push_back(tensor_to_vector(tennisball_pos_));
        ball_velocities_.push_back(tensor_to_vector(tennisball_lin_vel_));
        task_states_.push_back(tensor_to_vector(current_task_));

        // Publish joint commands
        auto msg = lbr_fri_idl::msg::LBRJointPositionCommand();
        auto robot_dof_targets_vec = tensor_to_vector(robot_dof_targets_);
        std::copy(robot_dof_targets_vec.begin(), robot_dof_targets_vec.end(), msg.joint_position.begin());
        joint_ref_pub_->publish(msg);

        // Log task state changes
        static int last_task_index = -1;
        int current_task_index = -1;
        for (int i = 0; i < 7; i++) {
            if (current_task_[i].item<float>() == 1.0) {
                current_task_index = i;
                break;
            }
        }
        
        if (current_task_index != last_task_index) {
            std::vector<std::string> task_names = {
                "Catching_Ball", "Stabilizing_Ball", "Stabilized_Ball", 
                "Moving_to_Target", "Stabilized_at_Target", "Throwing_Ball", "Stop_Manipulator"
            };
            RCLCPP_INFO(this->get_logger(), "Task transition: %s -> %s", 
                       (last_task_index >= 0 ? task_names[last_task_index].c_str() : "None"),
                       task_names[current_task_index].c_str());
            last_task_index = current_task_index;
        }

        t_++;
    }

    torch::Tensor compute_offset_point(const torch::Tensor& position, const torch::Tensor& orientation) {
        // Compute rotation matrix from quaternion
        Eigen::Quaterniond quat(
            orientation[0].item<double>(), 
            orientation[1].item<double>(), 
            orientation[2].item<double>(), 
            orientation[3].item<double>()
        );
        Eigen::Matrix3d rot_matrix = quat.normalized().toRotationMatrix();

        // Offset vector (2 cm along z-axis)
        Eigen::Vector3d offset_local(0, 0, 0.02);

        // Compute global offset
        Eigen::Vector3d global_offset = rot_matrix * offset_local;

        // Compute new point position
        return torch::tensor({
            position[0].item<double>() + global_offset(0),
            position[1].item<double>() + global_offset(1),
            position[2].item<double>() + global_offset(2)
        });
    }

    void save_output(const std::vector<std::vector<double>>& outputs, 
                     const std::string& output_file_path, 
                     const std::string& header = "") {
        std::ofstream file(output_file_path);
        if (!file.is_open()) {
            RCLCPP_ERROR(this->get_logger(), "Failed to open file: %s", output_file_path.c_str());
            return;
        }

        // Write header if provided
        if (!header.empty()) {
            file << header << "\n";
        }

        // Write data
        for (const auto& row : outputs) {
            for (size_t i = 0; i < row.size(); ++i) {
                file << row[i];
                if (i != row.size() - 1)
                    file << ",";
            }
            file << "\n";
        }

        file.close();
        RCLCPP_INFO(this->get_logger(), "Saved output to: %s", output_file_path.c_str());
    }

    void destroy_node() {
        // Prepare output directory
        std::string output_dir = "/home/user/kuka_rl_ros2/src/catch_and_throw/output_files/tm/optitrack";
        std::filesystem::create_directories(output_dir);

        // Save various outputs
        save_output(joint_targets_, output_dir + "/tm_received_joint_target_np.csv", 
                    "joint_0,joint_1,joint_2,joint_3,joint_4,joint_5,joint_6");
        save_output(joint_poses_, output_dir + "/tm_received_joint_pos_np.csv", 
                    "joint_0,joint_1,joint_2,joint_3,joint_4,joint_5,joint_6");
        save_output(joint_velocities_, output_dir + "/tm_received_joint_vel_np.csv", 
                    "joint_0,joint_1,joint_2,joint_3,joint_4,joint_5,joint_6");
        save_output(ee_poses_, output_dir + "/tm_received_ee_pos_np.csv", 
                    "pos_X,pos_Y,pos_Z");
        save_output(ee_orientations_, output_dir + "/tm_received_ee_orientation_np.csv", 
                    "or_w,or_x,or_y,or_z");
        save_output(ee_velocities_, output_dir + "/tm_received_ee_vel_np.csv", 
                    "lin_vel_X,lin_vel_Y,lin_vel_Z");
        
        // Save ball tracking data
        save_output(ball_positions_, output_dir + "/tm_ball_positions_np.csv", 
                    "ball_x,ball_y,ball_z");
        save_output(ball_velocities_, output_dir + "/tm_ball_velocities_np.csv", 
                    "ball_vx,ball_vy,ball_vz");
        
        // Save task states
        save_output(task_states_, output_dir + "/tm_task_states_np.csv", 
                    "catching,stabilizing,stabilized,moving_to_target,stabilized_at_target,throwing,stop");
        
        // Save additional filter-related outputs
        save_output(raw_action_history_, output_dir + "/tm_raw_actions_np.csv", 
                    "action_0,action_1,action_2,action_3,action_4,action_5,action_6");
        save_output(filtered_action_history_, output_dir + "/tm_filtered_actions_sg_np.csv", 
                    "action_0,action_1,action_2,action_3,action_4,action_5,action_6");

        RCLCPP_INFO(this->get_logger(), "Model outputs saved on shutdown.");
        rclcpp::Node::~Node();
    }

private:
    // Joint state callback
    void joint_states_callback(const sensor_msgs::msg::JointState::SharedPtr msg) {
        std::lock_guard<std::mutex> lock(mutex_);

        std::vector<std::string> desired_order = {
            "lbr_A1", "lbr_A2", "lbr_A3", "lbr_A4", 
            "lbr_A5", "lbr_A6", "lbr_A7"
        };

        // Extract joint positions and velocities in correct order
        std::vector<double> positions(7, 0.0);
        std::vector<double> velocities(7, 0.0);

        for (size_t i = 0; i < desired_order.size(); ++i) {
            auto it = std::find(msg->name.begin(), msg->name.end(), desired_order[i]);
            if (it != msg->name.end()) {
                size_t idx = std::distance(msg->name.begin(), it);
                positions[i] = msg->position[idx];
                velocities[i] = msg->velocity[idx];
            }
        }

        // Convert to torch tensors
        joint_positions_obs_ = torch::tensor(positions);
        joint_velocities_obs_ = torch::tensor(velocities);

        // Initialize robot_dof_targets if not set
        if (robot_dof_targets_.numel() == 0) {
            robot_dof_targets_ = torch::tensor(positions);
        }
    }

    // Pose callback
    void ee_pose_callback(const geometry_msgs::msg::Pose::SharedPtr msg) {
        std::lock_guard<std::mutex> lock(mutex_);

        // Store end effector pose and orientation
        ee_pose_ = torch::tensor({msg->position.x, msg->position.y, msg->position.z});
        ee_orientation_ = torch::tensor({
            msg->orientation.w, 
            msg->orientation.x, 
            msg->orientation.y, 
            msg->orientation.z
        });
    }

    // Velocity callback
    void ee_vel_callback(const geometry_msgs::msg::Twist::SharedPtr msg) {
        std::lock_guard<std::mutex> lock(mutex_);

        // Store linear and angular velocities
        ee_vel_ = torch::tensor({msg->linear.x, msg->linear.y, msg->linear.z});
        ee_angular_vel_ = torch::tensor({msg->angular.x, msg->angular.y, msg->angular.z});
    }

    // OptiTrack ball pose callback
    void ball_pose_callback(const geometry_msgs::msg::PoseStamped::SharedPtr msg) {
        std::lock_guard<std::mutex> lock(mutex_);
        
        auto current_time = this->now();
        torch::Tensor new_ball_pos = torch::tensor({
            msg->pose.position.x, 
            msg->pose.position.y, 
            msg->pose.position.z
        });

        // Calculate velocity if we have previous position and time
        if (tennisball_pos_.numel() > 0 && last_ball_time_.nanoseconds() > 0) {
            double dt = (current_time - last_ball_time_).seconds();
            if (dt > 0.001) {  // Avoid division by very small numbers
                torch::Tensor raw_velocity = (new_ball_pos - tennisball_pos_) / dt;
                
                // Apply low-pass filter to velocity
                tennisball_lin_vel_ = (*ball_velocity_filter_)(raw_velocity);
                
                // Store time for next calculation
                last_ball_time_ = current_time;
            }
        } else {
            // Initialize velocity to zero for first measurement
            tennisball_lin_vel_ = torch::zeros(3);
            last_ball_time_ = current_time;
        }

        // Update ball position
        tennisball_pos_ = new_ball_pos;
        
        // Log ball data periodically
        if (t_ % 50 == 0) {  // Log every 50 iterations
            RCLCPP_INFO(this->get_logger(), 
                       "Ball - Pos: [%.3f, %.3f, %.3f], Vel: [%.3f, %.3f, %.3f]", 
                       tennisball_pos_[0].item<float>(), tennisball_pos_[1].item<float>(), tennisball_pos_[2].item<float>(),
                       tennisball_lin_vel_[0].item<float>(), tennisball_lin_vel_[1].item<float>(), tennisball_lin_vel_[2].item<float>());
        }
    }

    // Member variables
    // Time and recording
    int t_;
    bool recording_;

    // Synchronization
    std::mutex mutex_;

    // ROS2 Communication
    rclcpp::Subscription<sensor_msgs::msg::JointState>::SharedPtr joint_states_sub_;
    rclcpp::Subscription<geometry_msgs::msg::Pose>::SharedPtr ee_pose_sub_;
    rclcpp::Subscription<geometry_msgs::msg::Twist>::SharedPtr ee_vel_sub_;
    rclcpp::Subscription<geometry_msgs::msg::PoseStamped>::SharedPtr ball_pose_sub_;
    rclcpp::Publisher<lbr_fri_idl::msg::LBRJointPositionCommand>::SharedPtr joint_ref_pub_;
    rclcpp::TimerBase::SharedPtr timer_;

    // Hyperparameters
    double dt_;
    double tennis_ball_pos_scale_;
    double lin_vel_scale_;
    double to_final_target_scale_;
    double dof_vel_scale_;
    double action_scale_;
    double to_throwing_pos_scale_;
    double to_throwing_vel_scale_;
    double moving_average_;
    double tennisball_radius_;

    // Task state machine indices
    int catching_ball_index_;
    int stabilizing_ball_index_;
    int stabilized_ball_index_;
    int moving_to_target_pos_index_;
    int stabilized_at_target_index_;
    int throwing_ball_index_;
    int stop_manipulator_index_;

    // Task state variables
    torch::Tensor current_task_;
    bool catched_ball_;
    bool stabilized_ball_;
    int stabilized_ball_counter_;
    int stabilized_ball_counter_at_target_;
    bool throwing_termination_;
    double revert_penalty_;

    // Ball tracking
    torch::Tensor tennisball_pos_;
    torch::Tensor tennisball_lin_vel_;
    rclcpp::Time last_ball_time_;
    std::unique_ptr<LowPassFilter> ball_velocity_filter_;

    // Savitzky-Golay filter
    std::unique_ptr<RealTimeSavitzkyGolay> action_filter_;

    // Tensors for observations and targets
    torch::Tensor joint_positions_obs_;
    torch::Tensor joint_velocities_obs_;
    torch::Tensor ee_pose_;
    torch::Tensor ee_orientation_;
    torch::Tensor ee_vel_;
    torch::Tensor ee_angular_vel_;

    // Policy and action-related tensors
    std::unique_ptr<DeploymentPolicy> policy_;
    torch::Tensor robot_dof_lower_limits_;
    torch::Tensor robot_dof_upper_limits_;
    torch::Tensor robot_dof_lower_limits_np_;
    torch::Tensor robot_dof_upper_limits_np_;
    torch::Tensor final_target_pos_;
    torch::Tensor throwing_pos_;
    torch::Tensor throwing_vel_;

    torch::Tensor action_history_;
    torch::Tensor action_logits_;
    torch::Tensor pure_action_;
    torch::Tensor robot_dof_targets_;

    // Output storage for logging/debugging
    std::vector<std::vector<double>> joint_targets_;
    std::vector<std::vector<double>> joint_poses_;
    std::vector<std::vector<double>> joint_velocities_;
    std::vector<std::vector<double>> ee_poses_;
    std::vector<std::vector<double>> ee_orientations_;
    std::vector<std::vector<double>> ee_velocities_;
    std::vector<std::vector<double>> ball_positions_;
    std::vector<std::vector<double>> ball_velocities_;
    std::vector<std::vector<double>> task_states_;
    std::vector<std::vector<double>> raw_action_history_;
    std::vector<std::vector<double>> filtered_action_history_;
};

int main(int argc, char *argv[]) {
    rclcpp::init(argc, argv);
    
    try {
        auto node = std::make_shared<JointStateNode>();
        
        // Handle shutdown gracefully
        auto shutdown_handler = [&node]() {
            RCLCPP_INFO(node->get_logger(), "Shutting down and saving data...");
            node->destroy_node();
            rclcpp::shutdown();
        };
        
        // Set up signal handler for graceful shutdown
        signal(SIGINT, [](int) {
            rclcpp::shutdown();
        });
        
        rclcpp::spin(node);
        shutdown_handler();
        
    } catch (const std::exception& e) {
        std::cerr << "Error in JointStateNode: " << e.what() << std::endl;
        return 1;
    } catch (...) {
        std::cerr << "Unknown error in JointStateNode" << std::endl;
        return 1;
    }
    
    return 0;
}